import os
import subprocess
import csv
import json

NUM_QUBITS = [2, 5, 10, 15, 20, 25]
NUM_GATES  = [10, 100, 1000, 10000]

# SAFETY LIMIT: Stop simulation if qubits > this (prevents RAM crashes)
MAX_SIM_QUBITS = 26 
MAX_CPU_QUBITS = 10
MAX_CPU_GATES  = 100

# OUTPUT FILENAME
FINAL_RESULTS_CSV = "results/results_combined.csv"

PATH_ROOT    = os.path.dirname(os.path.abspath(__file__))
PATH_DATA    = os.path.join(PATH_ROOT, "futhark/data")
PATH_HASKELL = os.path.join(PATH_ROOT, "interface/HQPlayground")
PATH_QISKIT  = os.path.join(PATH_ROOT, "qiskit")

# COMMAND TEMPLATES
CMD_HASKELL = ["cabal", "run", "benchmark", "--"] 
CMD_QISKIT  = ["python3", "benchmarking.py", "--file"]

def run_haskell(input_file):
    """
    Runs Haskell, saves to temp_criterion.csv, extracts 'Mean' time.
    """
    temp_csv = os.path.join(PATH_HASKELL, "temp_criterion.csv")
    
    # Construct Command: cabal run benchmarking -- <filename> --csv <temp_csv>
    cmd = CMD_HASKELL + [input_file, "--csv", "temp_criterion.csv"]
    
    # Clean up old file
    if os.path.exists(temp_csv): os.remove(temp_csv)

    print("   [Haskell] Running Criterion...")
    try:
        subprocess.run(
            cmd, 
            cwd=PATH_HASKELL, 
            check=True, 
            stdout=subprocess.DEVNULL, # Clean output
            stderr=subprocess.PIPE
        )

        if not os.path.exists(temp_csv):
            return None

        with open(temp_csv, 'r') as f:
            reader = csv.reader(f)
            headers = next(reader) # Skip header
            row = next(reader)     # Get first data row
            
            # Criterion CSV: Index 1 is Mean Time (seconds)
            mean_time = float(row[1])
            
            print(f"   [Haskell] Done. Mean: {mean_time:.6f}s")
            return mean_time

    except (subprocess.CalledProcessError, IndexError, ValueError):
        print("   [Haskell] Failed.")
        return None

def run_qiskit(input_file):
    """
    Runs Qiskit, saves to temp_pyperf.json, and calculates mean time from raw values.
    """
    temp_json = os.path.join(PATH_QISKIT, "temp_pyperf.json")
    
    # Construct Command: python benchmarking.py --file <filename> -o <temp_json> --fast
    cmd = CMD_QISKIT + [input_file, "-o", "temp_pyperf.json", "--fast"]

    if os.path.exists(temp_json): os.remove(temp_json)

    print("   [Qiskit]  Running Pyperf...")
    try:
        subprocess.run(
            cmd, 
            cwd=PATH_QISKIT, 
            check=True,
            stdout=subprocess.DEVNULL, # Clean output
            stderr=subprocess.PIPE
        )

        # Parse JSON generated by Pyperf
        with open(temp_json, 'r') as f:
            data = json.load(f)
        
        # --- Calculate Mean from Raw Values ---
        all_values = []
        runs = data['benchmarks'][0]['runs']
        for run in runs:
            if 'values' in run:
                all_values.extend(run['values'])
        
        if not all_values:
            print("   [Qiskit]  Error: No data.")
            return None
            
        mean_time = sum(all_values) / len(all_values)
        # --------------------------------------
        
        print(f"   [Qiskit]  Done. Mean: {mean_time:.6f}s")
        return mean_time

    except (subprocess.CalledProcessError, Exception):
        print("   [Qiskit]  Failed.")
        return None

def main():
    # Create the final results file
    with open(FINAL_RESULTS_CSV, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(["Qubits", "Gates", "Haskell_Time_s", "Qiskit_Time_s"])

        print(f"=== Starting Benchmark Suite ===")
        print(f"Saving to: {FINAL_RESULTS_CSV}\n")

        for q in NUM_QUBITS:
            # Skip runs that are too big for CPU simulators
            if q > MAX_SIM_QUBITS:
                print(f"--- Skipping Q={q} (Exceeds {MAX_SIM_QUBITS} limit) ---")
                continue

            for g in NUM_GATES:
                filename = f"{q}_{g}.in"
                filepath = os.path.join(PATH_DATA, filename)

                if not os.path.exists(filepath):
                    print(f"\n[Skip] Missing file: {filename}")
                    continue

                print(f"\n>>> Benchmarking: {q} Qubits, {g} Gates")

                # Run benchmarks
                if q >= MAX_CPU_QUBITS and g >= MAX_CPU_GATES:
                    print(f"   [Skip] Both Qubits and Gates exceed CPU limits ({MAX_CPU_QUBITS} Q, {MAX_CPU_GATES} G).")
                    h_time = None
                elif q > MAX_CPU_QUBITS:
                    print(f"   [Skip] Qubits exceed CPU limit ({MAX_CPU_QUBITS} Q).")
                    h_time = None
                else:
                    h_time = run_haskell(filepath)
                q_time = run_qiskit(filepath)

                # Save immediately if we have data
                # if h_time is not None or q_time is not None:
                #     writer.writerow([q, g, h_time, q_time])
                #     f.flush()
                writer.writerow([q, g, h_time, q_time])
                f.flush()

    print(f"\n=== Benchmark Complete ===")

if __name__ == "__main__":
    main()